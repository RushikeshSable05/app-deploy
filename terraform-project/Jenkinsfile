// Jenkinsfile (Declarative pipeline)
// Assumptions:
// - Jenkins agent (WSL) has `terraform` and `az` on PATH.
// - You have created Jenkins credentials with the IDs used below:
//     AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID
// - The terraform code and the 3 tfvars.json files exist at the relative paths you provided.
// - If your repo is not checked out into the Jenkins workspace automatically, see notes below
pipeline {
  agent any

  // Useful env to make terraform run non-interactive
  environment {
    TF_IN_AUTOMATION = "1"
  }

  parameters {
    booleanParam(name: 'AUTO_APPROVE', defaultValue: false, description: 'If true, terraform apply will auto-approve. If false, pipeline will ask for manual confirmation before apply.')
  }

  stages {
    stage('Prepare / Checkout (optional)') {
      steps {
        script {
          // Try to checkout from configured SCM (works if job is set up with SCM).
          // If checkout fails (e.g., you pasted this script in Pipeline script box and don't use SCM),
          // we simply continue and expect the files are already present in workspace.
          try {
            checkout scm
            echo "Checked out repository via SCM."
          } catch (err) {
            echo "Checkout via SCM skipped or failed. Assuming terraform-project is already in workspace."
            echo "If your files are on the Jenkins host at /home/jenkins/repos/terraform-project, uncomment copy command below."
            // Example of copying repo from a path on the Jenkins host into workspace:
            // sh 'cp -r /home/jenkins/repos/terraform-project .'
          }
        }
      }
    }

    // Login to Azure using Service Principal and export ARM_* env vars for Terraform
    stage('Azure Login & Env Setup') {
      steps {
        // Bind Jenkins credential values into environment variables for the shell
        withCredentials([
          string(credentialsId: 'AZURE_CLIENT_ID', variable: 'AZ_CLIENT_ID'),
          string(credentialsId: 'AZURE_CLIENT_SECRET', variable: 'AZ_CLIENT_SECRET'),
          string(credentialsId: 'AZURE_TENANT_ID', variable: 'AZ_TENANT_ID'),
          string(credentialsId: 'AZURE_SUBSCRIPTION_ID', variable: 'AZ_SUBSCRIPTION_ID')
        ]) {
          // Use a shell block to login and export ARM_* for azurerm provider
          sh '''
            echo "Logging in to Azure using Service Principal..."
            az login --service-principal -u "$AZ_CLIENT_ID" -p "$AZ_CLIENT_SECRET" --tenant "$AZ_TENANT_ID"
            az account set --subscription "$AZ_SUBSCRIPTION_ID"

            # Export variables Terraform's azurerm provider will pick up
            export ARM_CLIENT_ID="$AZ_CLIENT_ID"
            export ARM_CLIENT_SECRET="$AZ_CLIENT_SECRET"
            export ARM_TENANT_ID="$AZ_TENANT_ID"
            export ARM_SUBSCRIPTION_ID="$AZ_SUBSCRIPTION_ID"

            # Print a short confirmation (not printing secrets)
            az account show --query "{name:name, id:id}" -o table || true
          '''
        }
      }
    }

    // Stage to create Resource Group
    stage('Terraform - Resource Group (init → plan → apply)') {
      steps {
        script {
          // directory containing main tf for resource group
          def rgDir = "terraform-project/resource-deployment/resource_groups/app"

          dir(rgDir) {
            // initialize
            sh 'terraform init -input=false'

            // plan (uses JSON var file)
            sh "terraform plan -input=false -var-file=terraform.tfvars.json -out=tfplan_rg"

            // show plan in console
            sh 'terraform show -no-color tfplan_rg || true'

            // apply: either auto-approve (if param true) or prompt for approval
            if (params.AUTO_APPROVE.toBoolean()) {
              sh 'terraform apply -input=false -auto-approve tfplan_rg'
            } else {
              // manual approval step inside the pipeline
              input message: "Approve APPLY for Resource Group in ${rgDir}?"
              sh 'terraform apply -input=false -auto-approve tfplan_rg'
            }
          }
        }
      }
      post {
        success {
          echo "Resource Group apply completed."
        }
        failure {
          echo "Resource Group stage failed — check console logs."
        }
      }
    }

    // Stage to create VNet
    stage('Terraform - VNet (init → plan → apply)') {
      steps {
        script {
          def vnetDir = "terraform-project/resource-deployment/vnet01/app"

          dir(vnetDir) {
            sh 'terraform init -input=false'

            // plan: references the var file at this directory
            sh "terraform plan -input=false -var-file=terraform.tfvars.json -out=tfplan_vnet"

            sh 'terraform show -no-color tfplan_vnet || true'

            if (params.AUTO_APPROVE.toBoolean()) {
              sh 'terraform apply -input=false -auto-approve tfplan_vnet'
            } else {
              input message: "Approve APPLY for VNet in ${vnetDir}?"
              sh 'terraform apply -input=false -auto-approve tfplan_vnet'
            }
          }
        }
      }
    }

    // Stage to create Subnet
    stage('Terraform - Subnet (init → plan → apply)') {
      steps {
        script {
          def subnetDir = "terraform-project/resource-deployment/subnet01/app"

          dir(subnetDir) {
            sh 'terraform init -input=false'

            // plan: uses the provided json var file for subnet
            sh "terraform plan -input=false -var-file=terraform.tfvars.json -out=tfplan_subnet"

            sh 'terraform show -no-color tfplan_subnet || true'

            if (params.AUTO_APPROVE.toBoolean()) {
              sh 'terraform apply -input=false -auto-approve tfplan_subnet'
            } else {
              input message: "Approve APPLY for Subnet in ${subnetDir}?"
              sh 'terraform apply -input=false -auto-approve tfplan_subnet'
            }
          }
        }
      }
    }
  }

  post {
    always {
      // Try to output any terraform outputs found in each directory (best-effort)
      sh '''
        for d in terraform-project/resource-deployment/*/app; do
          if [ -d "$d" ]; then
            echo "---- Outputs for $d ----"
            (cd "$d" && terraform output -json) || true
          fi
        done
      '''
    }
  }
}
